# ROS & STM32 Tracked Chassis Control Project

This is a low-level control project for a tracked robot based on the STM32F407ZGT6. It communicates with a host computer (e.g., a Raspberry Pi or Orange Pi running ROS) via the `rosserial` protocol, implementing closed-loop PID control for both the speed and position of the chassis motors.

The code in this project has undergone a thorough debugging process, addressing a series of common issues ranging from hardware configuration and compiler compatibility to `rosserial` communication and PID parameter tuning. It aims to provide a stable, reliable, and easily expandable reference framework for building similar low-level robot systems.

## Project Highlights

*   **Modular Code Structure**: Decouples functionalities such as motor driving (`Motor`), encoder reading (`Encoder`), PID algorithm (`PID`), debug serial port (`Serial`), and main control logic (`Control`). This results in a clean code structure that is easy to maintain and port.
*   **Cascade PID Control**: Implements a **position loop (outer loop) + speed loop (inner loop)** cascade PID control, ensuring both precise positioning and a smooth response.
*   **`rosserial` Communication**: Achieves seamless integration with the ROS ecosystem by subscribing to the `/cmd_vel` (`geometry_msgs/Twist`) topic to receive commands from the host computer.
*   **Robust Debugging Framework**: Features a built-in debug mode switch, allowing for independent tuning of the inner (speed) and outer (position) PID loops by modifying a macro definition. It prints real-time data via the serial port for visual debugging with tools like `SerialPlot`.
*   **Hardware Abstraction**: All hardware-related initialization and low-level operations are configured and generated by STM32CubeMX and implemented using HAL library functions, ensuring good portability.

## Tech Stack

*   **Main MCU**: STM32F407ZGT6
*   **Motor Driver**: TB6612FNG
*   **Encoder**: 13 PPR AB-phase incremental encoder (with a 1:30 reduction gearbox)
*   **Development Environment**: STM32CubeIDE / Keil MDK 5 (configured for ARM Compiler 6)
*   **Communication Protocol**: `rosserial` over UART
*   **Host ROS Version**: ROS Noetic

---

## Quick Start and Configuration

To adapt this project for your own robot, you need to modify several key parameters based on your specific hardware.

### **[IMPORTANT] Parameters You Need to Modify**

All core parameters that require user modification are centralized in the **`Core/Src/Control.c`** file.

```c
// Core/Src/Control.c

// ====== 1. Robot Physical Parameters ======
// These parameters MUST be modified according to the actual measurements of your robot!

// [MODIFY] Distance between the centers of the two drive wheels (unit: cm)
const float WHEEL_SEPARATION_CM = 22.0f;

// [MODIFY] Total encoder pulses per one full revolution of the output shaft (i.e., the track drive wheel shaft)
// Formula: Motor_PPR * 4 (for quadrature decoding) * Gear_Ratio
// Example: 13 * 4 * 30 = 1560
const float ENCODER_PULSES_PER_REV = 1560.0f;

// [CALIBRATE] Number of encoder ticks generated per 1 cm of forward movement.
// This is the most critical parameter. It is highly recommended to calibrate it precisely
// through an "open-loop forward movement" test!
// Theoretical calculation: TICKS_PER_CM = ENCODER_PULSES_PER_REV / Track_Perimeter_in_cm
const float TICKS_PER_CM = 25.16f;


// ====== 2. PID Parameters ======
// These parameters need to be tuned iteratively for your specific motors and load
// using a serial plotting tool.

void Control_Init(void)
{
    // [TUNE] Inner Loop - Speed PID Parameters
    // Tune Kp first, then Ki and Kd.
    PID_Init(&pid_speed_left, 2.5f, 0.8f, 0.1f, 100.0f, -100.0f);
    PID_Init(&pid_speed_right, 2.5f, 0.8f, 0.1f, 100.0f, -100.0f);

    // [TUNE] Outer Loop - Position PID Parameters
    // Usually, Ki is set to 0 for the position loop.
    PID_Init(&pid_position_left, 0.1f, 0.0f, 0.0f, 80.0f, -80.0f);
    PID_Init(&pid_position_right, 0.1f, 0.0f, 0.0f, 80.0f, -80.0f);
}
```

## [IMPORTANT] Hardware Pin Configuration (.ioc file)

The pin assignments for this project have been carefully designed to avoid common conflicts. Please open the `.ioc` file in STM32CubeMX and ensure your hardware wiring matches the following configuration:

| Function                | Timer/GPIO   | STM32 Pin      |
| ----------------------- | ------------ | -------------- |
| Wheel B PWM             | TIM3_CH4     | PB1            |
| Wheel A PWM             | TIM3_CH3     | PB0            |
| Wheel A Encoder         | TIM4_CH1/2   | PB6 / PB7      |
| Wheel B Encoder         | TIM2_CH1/2   | PA15 / PB3     |
| Wheel B Direction 1 (AIN1) | GPIO         | PB14           |
| Wheel B Direction 2 (AIN2) | GPIO         | PB15           |
| Wheel A Direction 1 (BIN1) | GPIO         | PC4            |
| Wheel A Direction 2 (BIN2) | GPIO         | PC5            |
| ROS Communication       | USART3       | PB10 / PB11 (or other) |
| Debug Serial (UART)     | USART1       | PA9 / PA10     |
| Control Loop Timer      | TIM6         | (No pin out)   |
| User Button (KEY0)      | GPIO         | PE4            |

## Debugging Workflow

This project includes a robust debugging mode, configured at the top of `Core/Src/Control.c`.

```c
#define CONTROL_MODE 1 // 1: Tune Speed Loop, 2: Tune Position Loop, 3: Normal Operation
```

#### 1. Tuning the Speed Loop (Inner Loop):

1.  Set `CONTROL_MODE` to `1`.
2.  Modify the parameters for `pid_speed_...` in `Control_Init()`.
3.  Compile and flash the code. Connect to the debug serial port with a tool like `SerialPlot` to observe the waveform.
4.  **Goal**: Find a set of Kp, Ki, and Kd values that allow the actual speed to quickly and smoothly follow the target speed.

#### 2. Tuning the Position Loop (Outer Loop):

1.  Set `CONTROL_MODE` to `2`.
2.  Keep the `pid_speed_...` parameters fixed to the values you just tuned.
3.  Start modifying the `pid_position_...` parameters (usually starting with Kp).
4.  Compile, flash, and observe the waveform.
5.  **Goal**: Find a set of parameters that allows the current position to reach the target position quickly and smoothly without overshoot.

#### 3. Normal Operation:

1.  Set `CONTROL_MODE` to `3`.
2.  Uncomment the `setup()` and `loop()` calls in `main.c` to re-enable ROS communication.

Now, you can control your robot by publishing to the `/cmd_vel` topic from your host computer.

# ROS 与 STM32 履带底盘控制项目

这是一个基于 STM32F407ZGT6 的履带式机器人底层控制项目，通过 `rosserial` 协议与上位机（如树莓派、香橙派等运行 ROS 的设备）进行通信，实现了对底盘电机的速度和位置闭环 PID 控制。

本项目代码经历了详尽的调试过程，解决了从硬件配置、编译器兼容性到 `rosserial` 通信、PID 参数整定等一系列常见问题，旨在为构建类似的机器人底层系统提供一个稳定、可靠、易于扩展的参考框架。

## 项目亮点

*   **模块化代码结构**: 将电机驱动 (`Motor`)、编码器读取 (`Encoder`)、PID 算法 (`PID`)、调试串口 (`Serial`)、主控制逻辑 (`Control`) 等功能解耦，代码结构清晰，易于维护和移植。
*   **串级 PID 控制**: 实现了**位置环(外环) + 速度环(内环)**的串级 PID 控制，保证了定位的精确性和响应的平稳性。
*   **`rosserial` 通信**: 通过订阅 `/cmd_vel` (`geometry_msgs/Twist`) 话题接收上位机指令，实现了与 ROS 生态的无缝对接。
*   **强大的调试框架**: 内置了调试模式切换功能，可通过修改宏定义，方便地对内环（速度）和外环（位置）进行独立的 PID 参数整定，并通过串口打印实时数据，配合 `SerialPlot` 等工具进行可视化调试。
*   **硬件抽象**: 所有硬件相关的初始化和底层操作均由 STM32CubeMX 配置生成，并由HAL库函数实现，具有良好的可移植性。

## 技术栈

*   **主控 MCU**: STM32F407ZGT6
*   **电机驱动**: TB6612FNG
*   **编码器**: 13PPR AB相增量式编码器 (带 1:30 减速箱)
*   **开发环境**: STM32CubeIDE / Keil MDK 5 (已配置为 ARM Compiler 6)
*   **通信协议**: `rosserial` over UART
*   **上位机 ROS**: ROS Noetic

---

## 快速上手与配置

要将此项目应用到你自己的机器人上，你需要根据你的具体硬件情况，修改以下几个关键参数。

### **【重要】需要你修改的参数**

所有需要用户修改的核心参数都集中在 **`Core/Src/Control.c`** 文件中。

```c
// Core/Src/Control.c

// ====== 1. 机器人物理参数 ======
// 这些参数必须根据你的机器人实际测量值进行修改！

// 【修改】两个驱动轮中心之间的距离 (单位: 厘米)
const float WHEEL_SEPARATION_CM = 22.0f;

// 【修改】编码器输出轴（即履带驱动轮轴）每转一圈，编码器产生的总脉冲数
// 计算公式: 电机PPR * 4 (四倍频) * 减速比
// 示例: 13 * 4 * 30 = 1560
const float ENCODER_PULSES_PER_REV = 1560.0f;

// 【标定】每前进 1 厘米，编码器产生的脉冲数。
// 这是最关键的参数，强烈建议通过“开环前进”实验精确标定！
// 理论计算: TICKS_PER_CM = ENCODER_PULSES_PER_REV / 履带周长(cm)
const float TICKS_PER_CM = 25.16f;


// ====== 2. PID 参数 ======
// 这些参数需要你通过串口绘图工具，针对你的电机和负载进行反复调试。

void Control_Init(void)
{
    // 【调试】内环-速度环 PID 参数
    // 先调 Kp，再调 Ki, Kd
    PID_Init(&pid_speed_left, 2.5f, 0.8f, 0.1f, 100.0f, -100.0f);
    PID_Init(&pid_speed_right, 2.5f, 0.8f, 0.1f, 100.0f, -100.0f);

    // 【调试】外环-位置环 PID 参数
    // 通常 Ki 为 0
    PID_Init(&pid_position_left, 0.1f, 0.0f, 0.0f, 80.0f, -80.0f);
    PID_Init(&pid_position_right, 0.1f, 0.0f, 0.0f, 80.0f, -80.0f);
}
Use code with caution.
 ``` 

## 【重要】硬件引脚配置 (.ioc 文件)
本项目的引脚分配经过精心设计，以避开常见冲突。请在 STM32CubeMX 中打开 .ioc 文件，确保你的硬件接线与以下配置一致：
``` 
功能	定时器/GPIO	STM32 引脚
B轮 PWM	TIM3_CH4	PB1
A轮 PWM	TIM3_CH3	PB0
A轮编码器	TIM4_CH1/2	PB6 / PB7
B轮编码器	TIM2_CH1/2	PA15 / PB3
B轮方向 1	GPIO AIN1	PB14
B轮方向 2	GPIO AIN2	PB15
A轮方向 1	GPIO BIN1	PC4
A轮方向 2	GPIO BIN2	PC5
ROS 通信	USART3	PB10 / PB11 (或你选择的其他)
调试串口	USART1	PA9 / PA10
控制周期	TIM6	(无引脚)
用户按键	GPIO KEY0	PE4
``` 

## 调试流程
``` 
本项目内置了强大的调试模式，位于 Core/Src/Control.c 的顶部。
Generated c
#define CONTROL_MODE 1 // 1: 调速度环, 2: 调位置环, 3: 正常运行
Use code with caution.
C
调试速度环 (内环):
设置 CONTROL_MODE 为 1。
在 Control_Init() 中修改 pid_speed_... 的参数。
编译烧录，通过调试串口连接 SerialPlot 等工具，观察波形。
目标：找到一组能让实际速度快速、平稳地跟随目标速度的 Kp, Ki, Kd 值。
调试位置环 (外环):
设置 CONTROL_MODE 为 2。
在 Control_Init() 中，将 pid_speed_... 的参数固定为你刚刚调好的值。
开始修改 pid_position_... 的参数（通常从 Kp 开始）。
编译烧录，观察波形。
目标：找到一组能让当前位置快速、平稳地到达目标位置的参数。
正常运行:
设置 CONTROL_MODE 为 3。
取消 main.c 中对 setup() 和 loop() 的注释，恢复 ROS 通信。
``` 
现在，你可以通过在上位机发布 /cmd_vel 话题来控制你的机器人了。



